<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>TP03 - Web3D Complet</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
    <script>
      // --- Scène, caméra, rendu ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // --- Skybox avec couleurs unies ---
      const skyboxColors = [
        0x87ceeb, // px - bleu ciel
        0x87ceeb, // nx
        0xffffff, // py - blanc
        0x87ceeb, // ny
        0x87ceeb, // pz
        0x87ceeb, // nz
      ];
      const skyTextures = skyboxColors.map((color) => {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 64;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#" + color.toString(16).padStart(6, "0");
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
      });
      const skybox = new THREE.CubeTexture(skyTextures);
      scene.background = skybox;

      // --- Plan (sol) vert sombre ---
      const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
      const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x1e4d1e });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2;
      scene.add(plane);

      // --- Cube joueur jaune banane ---
      const cubeSize = 5;
      const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffeb3b });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.position.y = cubeSize / 2;
      scene.add(cube);

      // --- Caméra + OrbitControls ---
      camera.position.set(20, 15, 20);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.enablePan = false;
      controls.minDistance = 10;
      controls.maxDistance = 50;
      controls.maxPolarAngle = Math.PI / 2;
      controls.minPolarAngle = 0.3;
      controls.enableKeys = false;

      // --- Déplacements du cube ---
      const keys = {};
      const velocity = new THREE.Vector3();
      const acceleration = 0.05;
      const deceleration = 0.02;
      const maxSpeed = 0.5;
      let isOnGround = true;
      let jumpVelocity = 0;

      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => (keys[e.code] = false));

      function updatePlayer() {
        let moveX = 0,
          moveZ = 0;
        if (keys["KeyW"] || keys["KeyZ"]) moveZ -= 1;
        if (keys["KeyS"]) moveZ += 1;
        if (keys["KeyA"] || keys["KeyQ"]) moveX -= 1;
        if (keys["KeyD"]) moveX += 1;

        const moveVector = new THREE.Vector3(moveX, 0, moveZ);
        if (moveVector.length() > 0) {
          moveVector.normalize();

          // Déplacement relatif à la caméra
          const cameraDirection = new THREE.Vector3();
          camera.getWorldDirection(cameraDirection);
          cameraDirection.y = 0;
          cameraDirection.normalize();

          const cameraRight = new THREE.Vector3();
          cameraRight
            .crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection)
            .normalize();

          const relativeMove = new THREE.Vector3();
          relativeMove.addScaledVector(cameraDirection, -moveVector.z);
          relativeMove.addScaledVector(cameraRight, moveVector.x);

          velocity.x += relativeMove.x * acceleration;
          velocity.z += relativeMove.z * acceleration;
        } else {
          velocity.x *= 1 - deceleration;
          velocity.z *= 1 - deceleration;
        }

        velocity.x = Math.max(Math.min(velocity.x, maxSpeed), -maxSpeed);
        velocity.z = Math.max(Math.min(velocity.z, maxSpeed), -maxSpeed);

        // Saut
        if (keys["Space"] && isOnGround) {
          jumpVelocity = 0.6;
          isOnGround = false;
        }
        if (!isOnGround) {
          jumpVelocity -= 0.02;
          cube.position.y += jumpVelocity;
          if (cube.position.y <= cubeSize / 2) {
            cube.position.y = cubeSize / 2;
            isOnGround = true;
            jumpVelocity = 0;
          }
        }

        // Appliquer déplacement
        cube.position.x += velocity.x;
        cube.position.z += velocity.z;
      }

      // --- Animation ---
      function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        controls.target.copy(cube.position);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // --- Responsive ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
